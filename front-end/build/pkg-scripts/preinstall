#!/bin/bash
# preinstall — runs as root BEFORE the macOS Installer copies files.
# Ensures "Hedera Transaction Tool" is not running so the bundle can be
# replaced safely.  Supports both interactive (GUI) and headless (MDM / CLI)
# installations.

set -euo pipefail

APP_NAME="Hedera Transaction Tool"
PROCESS_NAME="Hedera Transaction Tool"
QUIT_TIMEOUT=30          # seconds to wait for a graceful quit
FORCE_QUIT_WAIT=2        # seconds to wait after force-quit

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

escape_for_applescript() {
  local s="$1"
  s="${s//\\/\\\\}"    # escape backslashes
  s="${s//\"/\\\"}"    # escape double quotes
  printf '%s' "$s"
}

is_running() {
  pgrep -x "${PROCESS_NAME}" >/dev/null 2>&1
}

has_gui_session() {
  # Returns 0 when a WindowServer session exists (i.e. someone is logged in
  # at the GUI).  Fails under pure SSH / MDM / CLI-only installs.
  pgrep -x "WindowServer" >/dev/null 2>&1
}

show_dialog() {
  local message
  message=$(escape_for_applescript "$1")
  local buttons="$2"          # e.g. '{"Cancel Installation", "Close and Continue"}'
  local default_button="$3"   # e.g. '"Close and Continue"'

  # Run osascript as the console user so the dialog appears on the right
  # desktop.
  local console_user
  console_user=$(/usr/sbin/scutil <<< "show State:/Users/ConsoleUser" \
                 | awk '/Name :/ { print $3 }')

  if [ -z "${console_user}" ] || [ "${console_user}" = "loginwindow" ]; then
    return 1   # no interactive user — treat as headless
  fi

  local console_uid
  console_uid=$(id -u "${console_user}")

  local title
  title=$(escape_for_applescript "${APP_NAME} Installer")

  launchctl asuser "${console_uid}" sudo -u "${console_user}" \
    /usr/bin/osascript -e "
      display dialog \"${message}\" \
        buttons ${buttons} \
        default button ${default_button} \
        with title \"${title}\" \
        with icon caution
    " 2>/dev/null
}

graceful_quit() {
  local escaped_name
  escaped_name=$(escape_for_applescript "${APP_NAME}")

  # Try Apple Event quit as the console user so it reaches the app's GUI session
  local console_user
  console_user=$(/usr/sbin/scutil <<< "show State:/Users/ConsoleUser" \
                 | awk '/Name :/ { print $3 }')

  if [ -n "${console_user}" ] && [ "${console_user}" != "loginwindow" ]; then
    local console_uid
    console_uid=$(id -u "${console_user}")
    launchctl asuser "${console_uid}" sudo -u "${console_user}" \
      /usr/bin/osascript -e "tell application \"${escaped_name}\" to quit" 2>/dev/null || true
  else
    /usr/bin/osascript -e "tell application \"${escaped_name}\" to quit" 2>/dev/null || true
  fi

  # Fallback: SIGTERM in case the Apple Event didn't reach the process
  pkill -15 -x "${PROCESS_NAME}" 2>/dev/null || true
}

force_quit() {
  pkill -9 -x "${PROCESS_NAME}" 2>/dev/null || true
}

wait_for_exit() {
  local timeout=$1
  local elapsed=0
  while is_running && [ "${elapsed}" -lt "${timeout}" ]; do
    sleep 1
    elapsed=$((elapsed + 1))
  done
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

if ! is_running; then
  exit 0   # App is not running — nothing to do.
fi

# ---- Headless / MDM path -------------------------------------------------
if ! has_gui_session; then
  # No GUI session — silently force-quit and proceed.
  graceful_quit
  wait_for_exit 5
  if is_running; then
    force_quit
    sleep "${FORCE_QUIT_WAIT}"
  fi
  exit 0
fi

# ---- Interactive (GUI) path -----------------------------------------------

result=$(show_dialog \
  "${APP_NAME} is currently running. It must be closed before the installation can continue." \
  '{"Cancel Installation", "Close and Continue"}' \
  '"Close and Continue"' \
) || {
  # Dialog failed (no console user, osascript error) — fall back to headless.
  graceful_quit
  wait_for_exit 5
  if is_running; then
    force_quit
    sleep "${FORCE_QUIT_WAIT}"
  fi
  exit 0
}

if echo "${result}" | grep -q "Cancel Installation"; then
  echo "User cancelled the installation."
  exit 1
fi

# User chose "Close and Continue" — send graceful quit.
graceful_quit
wait_for_exit "${QUIT_TIMEOUT}"

if is_running; then
  # App did not quit in time — offer force-quit.
  result=$(show_dialog \
    "${APP_NAME} did not close in time. Would you like to force-quit the application?" \
    '{"Cancel Installation", "Force Quit and Continue"}' \
    '"Force Quit and Continue"' \
  ) || {
    # Dialog failed — force-quit silently.
    force_quit
    sleep "${FORCE_QUIT_WAIT}"
    exit 0
  }

  if echo "${result}" | grep -q "Cancel Installation"; then
    echo "User cancelled the installation."
    exit 1
  fi

  force_quit
  sleep "${FORCE_QUIT_WAIT}"

  if is_running; then
    show_dialog \
      "${APP_NAME} could not be closed. Please quit the application manually and try again." \
      '{"OK"}' \
      '"OK"' \
    2>/dev/null || true
    echo "ERROR: Could not terminate ${APP_NAME}."
    exit 1
  fi
fi

exit 0
